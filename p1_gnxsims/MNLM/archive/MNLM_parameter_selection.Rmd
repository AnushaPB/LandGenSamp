---
title: "MNLM Parameter Selection"
author: "Anusha"
date: "11/12/2021"
output: html_document
---

```{r}
library("raster")
library("viridis")
wclim <- getData('worldclim', var='bio', res=2.5)
```

```{r}
#BIO1 = annual temp, BIO12 = annual prec
env <- stack(wclim$bio1, wclim$bio12)
names(env) <- c("temp","prec")
plot(env)
```

```{r fig.width = 10, fig.height=5}
x <- env
ldim <- 100
percent.na <- 0.10
nsamp <- 1000
testn = 1000
set.seed(10)

nlmer <- function(x, ldim, nsamp, percent.na = 0, testn = 1000, ldim.units = "pixels"){
  
  #convert from pixels to coordinate units (assumes x and y units are the same)
  if(ldim.units == "pixels"){
    ldimconv <- ldim*res(x)[1]
  } else if(ldim.units == "coords"){
    ldimconv <- ldimconv <- ldim
  }
  
  #Create buffered raster based on ldim (dimensions of subrasters)
  #so that when the subrasters are created in the next step they don't extend outside of the extent 
  #(only needed for xmax/ymax since the box is created by adding to an initial coordinate
  buffrast <- crop(x, extent(extent(x)[1],
                             extent(x)[2] - ldimconv,
                             extent(x)[3],
                             extent(x)[4] - ldimconv))
  
  #stack for saving rasters
  xstack <- stack()
  #df for saving box coords
  coords_df <- data.frame()
  #df for saving Moran's I
  Moran_df <- data.frame()
  #df for saving correlation
  cor_df <- data.frame()
  
  #vector to save initial cell values so the same subraster isn't sampled twice
  initvec <- c()
  
  #get non na cell numbers
  notna <- which(complete.cases(getValues(buffrast)))
  
  #loop to create subrasters
  for(i in 1:nsamp){
    
    #Initial conditions for while loops
    pna <- 1
	  tn <- 0
	  init <- 0
	  
	  #Loop through subrasters while the percent of NAs is above a threshold 
	  #AND while the number of attempts to get the raster to meet this condition is below 1000 (just so it doesn't run forever)
  	while(pna > percent.na & tn < testn){
  	  #Loop through initial points for the subraster corner that have not been sampled before
  	  while(init %in% initvec){
  	    init <- sample(notna, size=1)
  	  }
  	  #add point to vector so it isn't sampled again
  	  initvec <- c(initvec, init)
  	  #get coordinates of the initial corner (lower left)
  	  coord1 <- xyFromCell(buffrast, init)
  	  #add ldim to corner to get the upper right corner of the subraster
  	  coord2 <- coord1 + ldimconv
  	  #create coords object for cropping
    	coords <- c(coord1[1], coord2[1], coord1[2], coord2[2])
    	#crop raster with coords to get subraster
  	  newx <- crop(x, extent(coords))
  	  #calculate the percentage of NAs
  	  pna <- sum(is.na(getValues(newx)))/(ncell(newx)*nlayers(x))
  	  #tracker for number of loops
  	  tn <- tn + 1
  	}
	  if(pna <= percent.na){"failed to find a subraster below the NA threshold in testn attempts"}
	  
	  #xstack <- stack(xstack, newx)
	  #save coords to df
	  coords_df <- rbind(coords_df, coords)
	  
	  #calculate and save Moran's I for each subraster
	  newxM <- c()
	  for(n in 1:nlayers(newx)){
	    newxM[n] <- Moran(newx[[n]])
	  }
	  Moran_df <- rbind(Moran_df, newxM)
	  
	  #calculate and save pearson's correlation for each subraster
	  #calc correlation
	  newxcor <- layerStats(newx, 'pearson', na.rm=T)$`pearson correlation coefficient`
	  #reformat into long df format
	  #replace diag/upper with NAs (symmetrical matrix)
	  diag(newxcor) <- NA
	  newxcor[lower.tri(newxcor)] <- NA
	  #convert to long format
	  newxcor <- matrix(newxcor, 
	                    dimnames=list(t(outer(colnames(newxcor), rownames(newxcor),FUN=paste)), NULL))
	  #convert to dataframe
	  newxcor <- data.frame(newxcor)
	  #save rownames (pairs of vars) into new column
	  newxcor$vars <- rownames(newxcor)
	  #remove rownames
	  rownames(newxcor) <- NULL
	  #only save complete cases (remove NAs)
	  newxcor <- newxcor[complete.cases(newxcor),]
	  #save results
	  cor_df <- rbind(cor_df, newxcor)
  }
	
  #rename data frames
	colnames(Moran_df) <- names(x)
	colnames(cor_df) <- c("cor", "vars")
	
	#combine ouputs into a list
	outputs <- list(Moran_df, cor_df, xstack, coords_df)
	names(outputs) <- c("MoranI", "Correlation", "Rasters", "Coords")
	return(outputs)
}
```


```{r}
testdf <- nlmer(env, ldim = 100, percent.na = 0.10, testn = 1000, nsamp = 1000)
```

```{r fig.width=10, fig.height = 3}
par(mfrow = c(1,3))
d <- density(testdf$MoranI$temp)
plot(d, main = "Moran's I | Temperature", xlab = "Moran's I")
polygon(d, col = rgb(204, 204, 255, alpha = 150, maxColorValue = 255))
d <- density(testdf$MoranI$prec)
plot(d, main = "Moran's I | Precipitation", xlab = "Moran's I")
polygon(d, col = rgb(204, 204, 255, alpha = 150, maxColorValue = 255))
d <- density(testdf$Correlation$cor)
plot(d, main = "Correlation | Prec vs Temp", xlab = "Cor")
polygon(d, col = rgb(255, 127, 80, alpha = 150, maxColorValue = 255))
```

```{r fig.width=10, fig.height=6}
par(mfrow=c(1,2), mar = rep(1,4), oma = rep(0,4))
plot(x[[1]], axes = FALSE, legend = FALSE, box = FALSE, col = inferno(100), main = "temp")
for(i in 1:nrow(testdf$Coords)){
  coords <- testdf$Coords[i,]
  rect(coords[1], coords[3], coords[2], coords[4])
}
plot(log(x[[2]]), axes = FALSE, legend = FALSE, box = FALSE, col = mako(100), main = "log(prec)")
for(i in 1:nrow(testdf$Coords)){
  coords <- testdf$Coords[i,]
  rect(coords[1], coords[3], coords[2], coords[4])
}
```
