---
title: "Optimizing sampling design for landscape genomics: Simulation tests"
author: "Anusha P. Bishop, Drew E. Terasaki Hart, Ian J. Wang"
output: 
  html_document:
    toc: true
---

```{r, include = FALSE, warning = FALSE, message = FALSE, results = FALSE, include = FALSE}
library(vcfR)
library(adegenet)
library(here)
library(tidyverse)
library(nlraa)
library(minpack.lm)
source("general_functions.R")
source(here("p3_methods", "IBDIBE_functions.R"))

knitr::opts_chunk$set(echo = FALSE, cache = TRUE, warning = FALSE, results = FALSE, message = FALSE)

knitr::opts_chunk$set(echo = FALSE, cache = TRUE, warning = FALSE, results = FALSE, message = FALSE)
```

```{r functions}
get_stats <- function(K, phi, m, H, r){
  wdir <- here("p1_gnxsims", "gnx")
  folder_name <- paste0("ttestall_may2/GNX_mod-ttestall_K", K, "_phi", phi*100, "_m", m*100, "_seed1_H", H*100, "_r", r*100)
  file_name <- paste0("mod-ttestall_K", K, "_phi", phi*100, "_m", m*100, "_seed1_H", H*100, "_r", r*100, "_it-0_spp-spp_0_OTHER_STATS.csv")
  path <- here(wdir,  paste0(folder_name, "/it-0/spp-spp_0/", file_name))
  if (!file.exists(path)) {warning(paste0("File does not exist: ", path)); return(NULL)}
  df <- 
    read_csv(path) %>% 
    mutate(K = K, phi = phi, m = m, H = H, r = r)
  return(df)
}
```

# 1. Simulation tests

```{r format simulation stats}
combos <- expand.grid(K = c(1, 2), phi = c(0.5, 1), m = c(0.25, 1), H = c(0.05, 0.5), r = c(0.3, 0.6))

ls <- 
  pmap(combos, get_stats) %>% 
  compact()
  
df <- 
  ls %>%
  bind_rows() %>%
  mutate(group = paste0("K", K, "_phi", phi, "_m", m, "_H", H, "_r", r))

mean_df <-
  df %>%
  group_by(t) %>%
  drop_na(mean_fit) %>%
  summarise(mean_fit = mean(mean_fit, na.rm = TRUE), .groups = "drop")
```

# 2. Testing for equilibrium in population size
```{r, fig.width = 10, fig.height = 5}
# Test with population size
st_df <-
  bind_rows(map(ls, adf_test, nsteps = 1000, var = "Nt")) %>% 
  mutate(nsteps = as.character(nsteps)) %>%
  mutate(stationarity = p < 0.05) 

count_st <-
  st_df %>%
  group_by(t_start, t_end, nsteps) %>%
  summarize(stationarity = sum(stationarity)/n() * 100) %>%
  drop_na()

ggplot() +
  geom_rect(data = count_st, aes(xmin = t_start, xmax = t_end, ymin = -Inf, ymax = Inf, fill = stationarity), alpha = 0.9) +
  geom_vline(data = count_st, aes(xintercept = t_end), lty = "dashed", alpha = 0.5, col = "white") +
  geom_line(data = drop_na(df, Nt), aes(x = t, y = Nt, group = group), alpha = 0.3) +
  labs(x = "Timepoint", y = "Nt", fill = "% at\nstationarity") +
  scale_fill_viridis_c(option = "mako", end = 1, begin = 0.1, direction = -1, limits = c(15, 100)) +
  theme_classic() +
  scale_x_continuous(expand = c(0, 0)) +
  theme(strip.background = element_blank())
```

# 3. Testing for equilibrium in fitness

# 3.1 Stationarity test
```{r}
adf_test <- function(subdf, nsteps = NULL, var = "mean_fit", timepoints = NULL){
  # Creating a time series object
  ts <- 
    subdf %>% 
    pull(.data[[var]]) %>%
    ts()

  # Testing for stationarity of different time points
  # Note: used na.omit() instead of drop_na(mean_fit) because then the time series would be shorter than the original data
  # and the time points would not line up correctly
  if (is.null(timepoints)) timepoints <- map(seq(0, 3500, nsteps), function(x) x:(x+nsteps))
  p_value <- map_dbl(timepoints, ~tseries::adf.test(na.omit(ts[.x]), alternative = "stationary")$p.value)
  p_df <- data.frame(t_start = map_dbl(timepoints, 1), t_end = map_dbl(timepoints, ~.x[length(.x)]), p = p_value)
  
  ts_df <- 
    p_df %>%
    bind_cols(unique(select(subdf, K, phi, m, H, r))) %>%
    mutate(nsteps = as.character(nsteps))

  return(ts_df)
}

# Test for stationarity in mean fitness
st_df <-
  map(ls, adf_test, nsteps = 1000) %>% 
  bind_rows() %>%
  mutate(nsteps = as.character(nsteps)) %>%
  mutate(stationarity = p < 0.05) 

count_st <-
  st_df %>%
  group_by(t_start, t_end, nsteps) %>%
  summarize(stationarity = sum(stationarity)/n() * 100) %>%
  drop_na()

ggplot() +
  geom_rect(data = count_st, aes(xmin = t_start, xmax = t_end, ymin = -Inf, ymax = Inf, fill = stationarity), alpha = 0.9) +
  geom_vline(data = count_st, aes(xintercept = t_end), lty = "dashed", alpha = 0.5, col = "white") +
  geom_line(data = drop_na(df, mean_fit), aes(x = t, y = mean_fit, group = group), alpha = 0.3) +
  geom_line(data = mean_df, aes(x = t, y = mean_fit), lwd = 1) +
  labs(x = "Timepoint", y = "Mean fitness", fill = "% at\nstationarity") +
  scale_fill_viridis_c(option = "mako", end = 1, begin = 0, direction = -1, limits = c(15, 100)) +
  theme_classic() +
  scale_x_continuous(expand = c(0, 0)) +
  theme(strip.background = element_blank())
```

## 3.2 Plateau test

```{r, fig.width = 10, fig.height = 5}
# Adapted from: https://gradcylinder.org/post/linear-plateau/
jp_test <- function(subdf, nsteps = NULL, var = "mean_fit", timepoints = NULL){

  subdf <- subdf %>% drop_na(mean_fit)
  fit <- nlsLM(formula = mean_fit ~ SSlinp(t, a, b, jp), data = subdf)
  jp <- 
    summary(fit)$coefficients %>% 
    as.data.frame() %>%
    mutate(name = rownames(.)) %>%
    filter(name == "jp") %>%
    pull(Estimate) 
  
  jp_df <- 
    data.frame(jp = jp, pred = predict(fit), obs = subdf$mean_fit, resids = residuals(fit), t = subdf$t) %>%
    bind_cols(unique(select(subdf, K, phi, m, H, r))) 

  return(jp_df)
}

jp_df <-
  map(ls, jp_test) %>%
  bind_rows() %>%
  mutate(group = paste0("K", K, "_phi", phi, "_m", m, "_H", H, "_r", r))

mean_jp <-
  jp_df %>%
  summarize(mean = mean(jp, na.rm = TRUE))

ggplot() +
  geom_vline(data = jp_df, aes(xintercept = jp), lty = "dashed", alpha = 0.5, col = "tomato") +
  geom_line(data =jp_df, aes(x = t, y = obs, group = group), alpha = 0.3) +
  #geom_line(data =jp_df, aes(x = t, y = pred, group = group), alpha = 0.3, col = "red") +
  geom_vline(data = mean_jp, aes(xintercept = mean), lwd = 1.5, col = "tomato") +
  labs(x = "Timepoint", y = "Mean fitness", fill = "% at\nstationarity") +
  theme_classic() +
  scale_x_continuous(expand = c(0, 0)) +
  theme(strip.background = element_blank())

ggplot() +
  geom_vline(data = jp_df, aes(xintercept = jp), lty = "dashed", alpha = 0.5, col = "tomato") +
  geom_point(data =jp_df, aes(x = t, y = resids, group = group), alpha = 0.1, cex = 0.3) +
  geom_vline(data = mean_jp, aes(xintercept = mean), lwd = 1.5, col = "tomato") +
  labs(x = "Timepoint", y = "Model residuals", fill = "% at\nstationarity") +
  theme_classic() +
  scale_x_continuous(expand = c(0, 0)) +
  theme(strip.background = element_blank())
```

# 4. Testing for genetic equilibrium

```{r}
calc_stats <- function(x, t, stat = "mantel", cache = TRUE){
  # Create paths for loading data
  path <- here(x, "it-0", "spp-spp_0")

  # Create paths for loading vcf
  vcf_paths <- list.files(path, pattern = ".vcf", full.names = TRUE)
  vcf_path <- vcf_paths[grepl(paste0("_t-", t, "_"), vcf_paths)]

  # Get model name
  mod_name = gsub(".vcf", "", basename(vcf_path))

  # Output path
  if (stat == "mantel") out_path <- here(path, paste0(mod_name, "_t-", t, "_mantel.csv"))
  if (stat == "gea") out_path <- here(path, paste0(mod_name, "_t-", t, "_gea.csv"))
  if (cache & file.exists(out_path)){
    message("using cached file")
    return(read_csv(out_path))
  }

  # Load genetic data
  gen <- dos_cache(vcf_path)

  # Get geospatial data
  gsd_path <- gsub(".vcf", ".csv", vcf_path)
  gsd_df <- get_gsd(gsd_path)

  if (stat == "mantel") results <- calc_mantel(gen, gsd_df)
  if (stat == "gea") results <- calc_gea(gen, gsd_df)

  # Add model name
  results <- 
    results %>% 
    mutate(t = t, path = mod_name)

  # Write out the results
  write_csv(results, out_path)
    
  return(results)
}

dos_cache <- function(vcf_path){
  # Create paths for loading dosage
  dos_file_path <- gsub("/mod-(.*?)_", "/dos-\\1_", vcf_path)
  dos_file_path <- gsub(".vcf", ".csv", dos_file_path)
  # Check if dosage file exists
  # If yes: read from dosage
  if (file.exists(dos_file_path)) {
    gen <- get_dos(dos_file_path)
    message("using cached dosage file")
  # If no: read from vcf and write out dosage
  } else {
    gen <- get_gen(vcf_path)
    write.csv(gen, dos_file_path, row.names = TRUE)
    message("created dosage file")
  }
  return(gen)
}

calc_mantel <- function(gen, gsd_df){
  # Calculate genetic distance
  gendist <- calc_dist(gen)

  # Calculate geographic and environmental distance
  env1_dist <- as.matrix(dist(gsd_df[,"env1"], diag = TRUE, upper = TRUE))
  env2_dist <- as.matrix(dist(gsd_df[,"env2"], diag = TRUE, upper = TRUE))
  geo_dist <- as.matrix(dist(gsd_df[,c("x", "y")], diag = TRUE, upper = TRUE))

  # Create a list of distance matrices
  dist_list <- list(geo = geo_dist, env1 = env1_dist, env2 = env2_dist)

  # Apply the function to each distance matrix
  results <- 
    map(dist_list, ~vegan::mantel(gendist, .x, method="pearson", permutations=1)$statistic) %>%
    bind_rows(.id = "var")
  
  return(results)
}

# Calculate genotype-env correlation
calc_gea <- function(gen, gsd_df){
  cor1 <- map(gen, ~cor.test(.x, gsd_df$env1))
  cor2 <- map(gen, ~cor.test(.x, gsd_df$env2))
  p1 <- map_dbl(cor1, "p.value")
  p2 <- map_dbl(cor2, "p.value")
  r1 <- map_dbl(cor1, "estimate")
  r2 <- map_dbl(cor2, "estimate")

  result <- 
    data.frame( 
      sampstrat = "full", 
      cor1_p = p1,
      cor2_p = p2,
      cor1_r = r1,
      cor2_r = r2,
      adaptive = c(rep(TRUE, 8), rep(FALSE, 1000))
    )

  result <-
    result %>%
    mutate(cor1_sig = cor1_p < 0.05, cor2_sig = cor2_p < 0.05, cor_sig = (cor1_sig + cor2_sig)/2)
}
```

```{r}
# list folders in the gnx directory
dirs <- list.dirs(here("p1_gnxsims", "gnx"), full.names = TRUE, recursive = FALSE)
dirs <- dirs[grepl("GNX_mod-test2", dirs)]

# get the stats for each folder across all time steps
combos <- expand.grid(x = dirs, t = seq(0, 10000, 500))
```

# 4.1 Gene flow test
```{r}
mantel_results <- 
  pmap(
    combos, \(x, t) calc_stats(x, t, stat = "mantel"),
   .progress = TRUE
   ) %>%
  compact() %>%
  bind_rows()

mantel_ggdf <- 
  mantel_results %>%
  mutate(env = env1 + env2) %>%
  pivot_longer(c(geo, env)) %>%
  mutate(mod = case_when(grepl("_K1_", path) ~ "High structure", TRUE ~ "Low structure")) %>%
  mutate(seed = case_when(grepl("seed1", path) ~ 1, grepl("seed2", path) ~ 2, grepl("seed3", path) ~ 3)) %>%
  mutate(group = paste0(mod, "_", name, "_", seed)) %>%
  mutate(name = case_when(name == "geo" ~ "A. Geographic distance", name == "env" ~ "B. Environmental distance")) 

ggplot(mantel_ggdf) +
  # add lines every 1000 steps
  geom_vline(xintercept = seq(0, 10000, 1000), alpha = 1, linetype = "dotted", col = "gray") +
  geom_line(aes(x = t, y = value, group = group, col = mod)) +
  theme_classic() +
  labs(col = "Simulation") +
  facet_wrap(~name, ncol =1, scales = "free") +
  labs(x = "Timepoint", y = "Mantel's r") +
  ylim(-0.01, 1) +
  scale_color_manual("Simulation", values = c("High structure" = "#17c3b2", "Low structure" = "#7678ed")) +
  # label the x axis every 2000 steps
  scale_x_continuous(breaks = seq(0, 10000, 2000)) +
  # left align the strip labels
  theme(panel.border = element_blank(),
        strip.background = element_blank(),
        panel.background = element_blank(),
        strip.text = element_text(size = 12, hjust = 0),
        axis.text = element_text(size = 11),
        title = element_text(size = 12),
        panel.spacing = unit(0.6, "lines"),
        legend.position = "right",
        strip.placement = "outside") 
```

# 4.1 Genotype-environment correlation test
```{r}
gea_results <- 
  pmap(
    combos, \(x, t) calc_stats(x, t, stat = "gea"),
   .progress = TRUE
   ) %>%
  compact() %>%
  bind_rows()

gea_ggdf <- 
  gea_results %>%
  group_by(adaptive, t, path) %>%
  mutate(cor1_rNA = case_when(is.na(cor1_r) ~ 0, TRUE ~ cor1_r), cor2_rNA = case_when(is.na(cor2_r) ~ 0, TRUE ~ cor2_r)) %>%
  summarise(across(c(cor1_rNA, cor2_rNA, cor1_r, cor2_r), ~mean(abs(.x), na.rm = TRUE))) %>%
  mutate(cor_rNA = (cor1_rNA + cor2_rNA)/2, cor_r = (cor1_r + cor2_r)/2) %>%
  pivot_longer(c(cor_r, cor_rNA)) %>%
  mutate(rtype = case_when(name == "cor_rNA" ~ "Fixed loci included (r = 0)", name == "cor_r" ~ "Fixed loci removed (r = NA)") ) %>%
  mutate(mod = case_when(grepl("_K1_", path) ~ "High structure", TRUE ~ "Low structure")) %>%
  mutate(seed = case_when(grepl("seed1", path) ~ 1, grepl("seed2", path) ~ 2, grepl("seed3", path) ~ 3)) %>%
  mutate(group = paste0(mod, "_", adaptive, "_", seed)) %>%
  mutate(name = case_when(adaptive ~ "A. Adaptive loci", !adaptive ~ "B. Neutral loci")) 

ggplot(gea_ggdf) +
  # add lines every 1000 steps
  geom_vline(xintercept = seq(0, 10000, 1000), alpha = 1, linetype = "dotted", col = "gray") +
  geom_line(aes(x = t, y = value, group = group, col = mod)) +
  theme_classic() +
  labs(col = "Simulation") +
  facet_grid(rtype~name) +
  labs(x = "Timepoint", y = "Mean environmental correlation") +
  #ylim(-0.01, 1) +
  scale_color_manual("Simulation", values = c("High structure" = "#17c3b2", "Low structure" = "#7678ed")) +
  # label the x axis every 2000 steps
  scale_x_continuous(breaks = seq(0, 10000, 2000)) +
  # left align the strip labels
  theme(panel.border = element_blank(),
        strip.background = element_blank(),
        panel.background = element_blank(),
        strip.text = element_text(size = 12, hjust = 0),
        axis.text = element_text(size = 11),
        title = element_text(size = 12),
        panel.spacing = unit(0.6, "lines"),
        legend.position = "right",
        strip.placement = "outside") 

```