---
title: "sampling_strategies_test"
author: "Anusha"
date: "7/21/2021"
output: html_document
---
#libraries
```{r}
library("foreach")
library("doParallel")
library("vcfR")
source("general_functions.R")

```

#test data
```{r}
gsd_df <- read.csv("/Users/Anusha/Documents/GitHub/LandGenSamp/p2_sampling/data/GNX_mod-K2_phi50_m25_seed3_H50_r30/it--1/spp-spp_0/mod-K2_phi50_m25_seed3_H50_r30_it--1_t-1000_spp-spp_0.csv")
gen_df <- get_gen("/Users/Anusha/Documents/GitHub/LandGenSamp/p2_sampling/data/GNX_mod-K2_phi50_m25_seed3_H50_r30/it--1/spp-spp_0/mod-K2_phi50_m25_seed3_H50_r30_it--1_t-1000_spp-spp_0.vcf")
```



# Grid Sampling

## Single File
*Problem:* once you get to higher resolutions of grid cells (e.g. 15x15, 18x18) you can end up with cells with no individuals in them. This results in the number of samples being lower than what you would get if exactly one individual was sampled from each cell (e.g. a smaller sample size than intended)
```{r Solution 1: ignore this problem since the difference is only a few individuals}
npts <- c(36, 81, 144, 225, 324)
pts <- gsd_df[,c("idx","x","y")]

dim <- 40
subs <- vector(mode = "list", length = length(npts))
for(n in 1:length(npts)){
  inc <- dim/sqrt(npts[n])
  xgrid <- ygrid <- seq(0, dim, inc) 
    for(i in 1:(length(xgrid)-1)){ 
      for(j in 1:(length(ygrid)-1)){ 
        gridsq = subset(pts, y > ygrid[j] & y < ygrid[j+1] & x > xgrid[i] & x < xgrid[i+1]) 
        if(dim(gridsq)[1]>0){ subs[[n]] = rbind(subs[[n]], gridsq[sample(1:dim(gridsq)[1],1 ), ]) }
        } 
    }
  par(pty="s")
  plot(subs[[n]]$x, subs[[n]]$y, pch=19, cex=0.5, main = nrow(subs[[n]]))
  abline(h = ygrid, v = xgrid, col="gray", lty="dashed")
}

```
```{r Solution 2: continue subsampling grid until the number of individuals desired is obtained, fig.width=6, fig.height=8}

par(pty="s", mfrow=c(3,2))
npts <- c(36, 81, 144, 225, 324)
pts <- gsd_df[,c("idx","x","y")]

dim <- 40
subs <- vector(mode = "list", length = length(npts))
for(n in 1:length(npts)){
  inc <- dim/sqrt(npts[n])
  xgrid <- ygrid <- seq(0, dim, inc) 
  #furst round of sampling: entire grid
  for(i in 1:(length(xgrid)-1)){ 
    for(j in 1:(length(ygrid)-1)){ 
      gridsq = subset(pts, y > ygrid[j] & y < ygrid[j+1] & x > xgrid[i] & x < xgrid[i+1]) 
      if(dim(gridsq)[1]>0){ subs[[n]] = rbind(subs[[n]], gridsq[sample(1:dim(gridsq)[1],1 ), ]) }
      } 
    }
  #reset grid indices
  i=1
  j=1
  #second round of sampling: cycle through gridcells again until number of desired samples is reached
  while(nrow(subs[[n]]) != npts[n] & i < (length(xgrid)-1) & j < (length(ygrid)-1)){
    i = i+1
    j = j+1
    gridsq = subset(pts, y > ygrid[j] & y < ygrid[j+1] & x > xgrid[i] & x < xgrid[i+1]) 
    if(dim(gridsq)[1]>0){ subs[[n]] = rbind(subs[[n]], gridsq[sample(1:dim(gridsq)[1],1 ), ])}
    }

  plot(subs[[n]]$x, subs[[n]]$y, pch=19, cex=0.5, main = nrow(subs[[n]]))
  abline(h = ygrid, v = xgrid, col="gray", lty="dashed")
  }
```
## All Files
```{r}
library("here")
library("foreach")
library("doParallel")
source("general_functions.R")
```

```{r}
grid_samp <- function(pts, npts){
  inc <- dim/sqrt(npts)
  xgrid <- ygrid <- seq(0, dim, inc) 
  subs <- c()
  #first round of sampling: entire grid
  for(i in 1:(length(xgrid)-1)){ 
    for(j in 1:(length(ygrid)-1)){ 
      gridsq = subset(pts, y > ygrid[j] & y < ygrid[j+1] & x > xgrid[i] & x < xgrid[i+1]) 
      if(dim(gridsq)[1]>0){ subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ]) }
      } 
    }
  #reset grid indices
  i=1
  j=1
  #second round of sampling: cycle through gridcells again until number of desired samples is reached
  while(nrow(subs) != npts & i < (length(xgrid)-1) & j < (length(ygrid)-1)){
    i = i+1
    j = j+1
    gridsq = subset(pts, y > ygrid[j] & y < ygrid[j+1] & x > xgrid[i] & x < xgrid[i+1]) 
    if(dim(gridsq)[1]>0){subs = rbind(subs, gridsq[sample(1:dim(gridsq)[1],1 ), ])}
  }
  return(subs$idx)
}

```

```{r}
#number of points to sample
npts <- c(36, 81, 144, 225, 324)

#register cores
cores <- detectCores()
cl <- makeCluster(cores[1]-3) #not to overload your computer
registerDoParallel(cl)

for(n in npts){
  samples <- foreach(i=1:length(params), .combine=rbind) %dopar% {
  library("here")
    
  #create file path
  gsd_filepath <- create_filepath(i, "gsd")
  
  #skip iteration if file does not exist
  skip_to_next <- FALSE
  if(file.exists(gsd_filepath) == FALSE){skip_to_next <- TRUE}
  if(skip_to_next) { print("File does not exist:")
                      print(params[i,]) } 
  if(skip_to_next) { result <- NA } 
  
  #run sampling
  if(skip_to_next == FALSE){
    gsd_df <- get_gsd(gsd_filepath)
    pts <- gsd_df[,c("idx","x","y")]
    samples <- grid_samp(pts, npts = n)
  }
  
  #return vector of sample IDs
  return(samples)
  
  }
  
  #bind sample IDs together and export (rows are parameter sets/columns are individual IDs)
  samp_out <- cbind.data.frame(params, samples)
  write.csv(samps_out, paste0("outputs/samples_grid",n,".csv"))
}


#stop cluster
stopCluster(cl)

```

# Random Sampling
```{r}
library("here")
library("foreach")
library("doParallel")
source("general_functions.R")
```

```{r}
#number of points to sample
npts <- c(36, 81, 144, 225, 324)

#register cores
cores <- detectCores()
cl <- makeCluster(cores[1]-3) #not to overload your computer
registerDoParallel(cl)

for(n in npts){
  samples <- foreach(i=1:length(params), .combine=rbind) %dopar% {
  library("here")
    
  #create file path
  gsd_filepath <- create_filepath(i, "gsd")
  
  #skip iteration if file does not exist
  skip_to_next <- FALSE
  if(file.exists(gsd_filepath) == FALSE){skip_to_next <- TRUE}
  if(skip_to_next) { print("File does not exist:")
                      print(params[i,]) } 
  if(skip_to_next) { result <- NA } 
  
  #run sampling
  if(skip_to_next == FALSE){
    gsd_df <- get_gsd(gsd_filepath)
    #take random sample
    samples <- gsd_df[sample(1:nrow(gsd_df), n), "idx"]
  }
  
  #return vector of sample IDs
  return(samples)
  
  }
  
  #bind sample IDs together and export (rows are parameter sets/columns are individual IDs)
  samp_out <- cbind.data.frame(params, samples)
  write.csv(samps_out, paste0("outputs/samples_rand",n,".csv"))
}


#stop cluster
stopCluster(cl)

```

# Transect Sampling

## Single File
```{r}
ygrid = c(10, 20, 30)
buffer = 1
ygrid1 = ygrid - buffer
ygrid2 = ygrid + buffer
par(pty="s")
plot(gsd_df$x, gsd_df$y, pch=19, cex=0.5)
abline(h = ygrid, col="gray", lty="dashed")
abline(h = ygrid1, col="blue", lty="dashed")
abline(h = ygrid2, col="red", lty="dashed")
```

##All xfiles

```{r fig.width=4, fig.height=7}

#Transect Sampling

transect_samp <- function(pts, npts, ytsct, buffer){
  #pts - dataframe with IDs and coords
  #npts - total number of points to sample (evenly split across transects)
  #buffer - buffer around transects within which points are sampled 
  
  #divide number of samples evenly among the transects
  npts_tsct <- npts/length(ytsct)
    
  #plot all points (gray) (for debugging, comment out later)
  par(pty="s")
  plot(gsd_df$x, gsd_df$y, pch=19, cex=0.2, col="gray", main = npts)
    
  #create empty vector to store IDs
  IDvec <- c()
  for(i in 1:length(ytsct)){ 
    #subset points around transect based on buffer
    tsctsq <- subset(pts, y > (ytsct[i] - buffer) & y < (ytsct[i] + buffer))
    #randomly sample subset of transect points to match number of samples needed for each transect
    tsctsq <- tsctsq[sample(nrow(tsctsq), npts_tsct),]
    #plot points sampled (for debugging, comment out later)
    points(tsctsq$x, tsctsq$y, col=i+1)
    #store IDs in list
    IDvec <- c(IDvec, tsctsq$idx)
  }
  
  #confirm correct number of samples were subsetted
  stopifnot(npts == length(IDvec))
  
  #return vec of sample IDs
  return(IDvec)
}

#vec of number of sample points
npts_vec <- c(36, 81, 144, 225, 324)
#horizontal transects (y-coords)
ytsct <- c(10, 20, 30)
#buffer around transects
buffer <- 1

#EXAMPLE
gsd_df <- read.csv("mod-K2_phi50_m25_seed3_H50_r30_it--1_t-1000_spp-spp_0.csv")
#subset out necessary columns from df
pts <- gsd_df[,c("idx","x","y")]

#plot of transects and buffer
par(pty="s")
plot(pts$x, pts$y, pch=19, col="gray", cex=0.2)
abline(h = ytsct, col="black", lty="dashed", lwd=2)
abline(h = ytsct + buffer, col="red", lty="dashed")
abline(h = ytsct - buffer, col="red", lty="dashed")


par(pty="s", mfrow = c(3,2))
#create list to store IDs of samples
subs <- vector(mode = "list", length = length(npts_vec))
for(n in 1:length(npts_vec)){
  subs[[n]] <- transect_samp(pts, npts_vec[n], ytsct, buffer)
}

```

#subsetting tests
```{r}
vcf <- read.vcfR("/Users/Anusha/Documents/GitHub/LandGenSamp/p2_sampling/data/GNX_mod-K2_phi50_m25_seed3_H50_r30/it--1/spp-spp_0/mod-K2_phi50_m25_seed3_H50_r30_it--1_t-1000_spp-spp_0.vcf")
gen <- vcfR2genlight(vcf) #CHECK THIS
genmat <- as.matrix(gen)
rownames(genmat) <- gen@ind.names

genmat[as.character(subs[[1]]$idx),1:5]
```

## subsetting data frame
```{r}
subIDs <- read.csv("outputs/samples_rand36.csv")
param_set <- params[1,]
subIDs <- subIDs[subIDs$K == param_set$K 
                 & subIDs$phi == param_set$phi
                 & subIDs$m == param_set$m 
                 & subIDs$seed == param_set$seed
                 & subIDs$H == param_set$H
                 & subIDs$r == param_set$r
                 & subIDs$it == param_set$it,]

#confirm there is only one set of IDs being used
stopifnot(nrow(subIDs) == 1)

#remove parameter columnds and convert to vector of IDs
subIDs <- subIDs[,!names(subIDs) %in% colnames(params)]
subIDs <- unlist(subIDs)

#confirm that final set of IDs is a vector
stopifnot(is.vector(subIDs))

```

```{r}
subIDs <- read.csv("outputs/samples_rand36.csv")
for(i in 1:nrow(params[1:2,])){
  
}
```

