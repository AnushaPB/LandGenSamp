---
title: "slattice"
output: html_document
date: "2023-07-31"
---
```{r}
library(slattice)
```


This vignette demonstrates how to use the slattice package to make inference about selection coefficients from time series data. This theory and implementation is described in the paper *Estimating Selection Coefficients in Spatially Structured Populations from Time Series Data of Allele Frequencies*, available [here](http://www.genetics.org/content/193/3/973)

## Single population case

First, simulate some data under a Wright-Fisher model using the `generate.observations` function: 

```{r}
Ne <- 1000                              #N_e
g<-100                                  #Number of generations
p0 <- 0.1                               #Initial freq
s <- 0.05                               #Selection coefficient
data<-generate.observations(Ne, g, p0, s, missing.p=0.8, size.params=list(N=100,p=0.5))
```

The data is a data frame with one row per generation, and two columns named `N` for the total number of chromosomes observed and `N.A` for the total number that carry the allele that is under selection. 

```{r}
head(data$obs)
```

Run the EM estimator using the default "Soft EM" algorithm. The output is an object that constains the estimated selection coefficient, and various other information including the posterior decoding of the frequency. Set `verbose=FALSE` to avoid seeing any output. 


```{r, fig.show='hold'}
estimate <- estimate.s(data$obs[1:100,], Ne, method="Soft EM", verbose=TRUE)
```

```{r}
estimate$s
```

## Lattice case

Simulate data under the Wright-Fisher lattice model. 

```{r}
k1 <- 10                               #Number of rows of demes
k2 <- 10                                 #Number of cols of demes
Ne <- 1000                               #N_e in each deme
g<-100                                  #Number of generations
p0 <- 0.1                               #Initial frequency
s <- matrix(0.06*seq(1,-1,length.out=k1), k1, k2, byrow=FALSE) #S^{ij} - matrix of selection coefficients
m <- 0.04                                #Scaled migration rate
lattice.data<-generate.lattice.observations(Ne, g, p0, s, k1, k2, Ne*m, missing.p=0.9, size.params=list(N=100, p=0.5))
```

Now run the lattice EM estimator. The output includes the final estimates, as well as all the posterior decodings. Here we set `verbose=FALSE` to avoid plotting the intermediate steps. You do not need to specify `initial.M`, but the estimator seems to perform better if you do. 

```{r}

test <- lattice.data
test$obs$N <- test$obs$N [,,c(1:20,100)]
test$obs$N.A <- test$obs$N.A[,,c(1:20,100)]
test$f <- test$f[,,c(1:20,100)]
lattice.estimate <- estimate.s.m(test$obs, Ne, M = NULL, update="Soft EM", max.iters=10, verbose=FALSE)
```

A nice way to plot the combined observations and results: 

```{r, fig.show='hold', fig.width = 6, fig.height = 6}
plot.wright.fisher.lattice.observations(test$obs, test$f, lattice.estimate$f, est.s=lattice.estimate$s, error.bars=FALSE, main="Lattice Example")
```

```{r, fig.width = 5, fig.height = 4.5}
library(here)
library(tidyverse)
library(slattice)
tdf_to_mat <- function(time, sl, r){
  x <- 
    sl %>% 
    filter(t == !!time) %>%
    right_join(data.frame(group = 1:raster::ncell(r)), by = "group") %>%
    mutate(N = replace_na(N, 0), N.A = replace_na(N.A, 0))
  
  N.A <- raster::as.matrix(raster::setValues(r, x$N.A))
  N <- raster::as.matrix(raster::setValues(r, x$N))
  
  return(list(N = N, N.A = N.A))
}


dim = 10
r <- raster::raster(nrows = dim, ncols = dim, xmn = 0, xmx = 100, ymn = -100, ymx = 0, vals = 1:(dim^2))
names(r) <- "r"

gsd <- read.csv(here("phi100_slattice_df.csv"))
gsd$group <- raster::extract(r, gsd[,c("x","y")])

make_slat <- function(locus, gsd){
  sl <- 
    gsd %>%
    group_by(t, group) %>%
    summarize(N.A = sum(get(locus)),
              N = n()*2, 
              env1 = mean(env1),
              env2 = mean(env2), 
              z1 = mean(z1), 
              z2 = mean(z2),
              .groups = "keep")
  
  a <- 
    map(unique(sl$t), ~tdf_to_mat(.x, sl = sl, r = r)) %>%
    list_transpose() %>%
    map(~array(unlist(.x), dim = c(dim,dim,length(.x))))
  
  return(a)
}

slat <- map(colnames(gsd)[grepl("X0_*", colnames(gsd))][1], ~make_slat(.x, gsd))

lattice.estimate <- map(slat[1], ~estimate.s.m(.x, Ne = 382, M = NULL, update = "Soft EM", max.iters = 10, verbose = FALSE))

div_colors <- RColorBrewer::brewer.pal(n = 11, name = "RdYlBu")

sr <- map(lattice.estimate, ~raster::setValues(r, .x$s))

sl <- 
    gsd %>%
    group_by(group) %>%
    summarize(N = n()*2, 
              env1 = mean(env1),
              env2 = mean(env2), 
              z1 = mean(z1), 
              z2 = mean(z2))

er <- raster::setValues(r, sl$env1)

par(mar = rep(1,4))
raster::plot(raster::stack(sr), col = div_colors, zlim = c(-0.3,0.3), axes = FALSE, box = FALSE)
raster::plot(er, col = div_colors, axes = FALSE, box = FALSE)

summary(map_dbl(sr, ~mean(abs(raster::values(.x)))))
```

```{r, fig.width = 5, fig.height = 4.5}
par(mar =rep(1,4))
raster::plot(r10, col = div_colors, zlim = c(-0.3,0.3), axes = FALSE, box = FALSE, main = "phi = 0.10")
raster::plot(r50, col = div_colors, zlim = c(-0.3,0.3), axes = FALSE, box = FALSE, main = "phi = 0.50")
raster::plot(r100, col = div_colors, zlim = c(-0.3,0.3), axes = FALSE, box = FALSE, main = "phi = 1.00")
```

```{r}
df <- data.frame(phi10 = values(r10), phi50 = values(r50), phi100 = values(r100))
colnames(df) <- c("phi10", "phi50", "phi100")
df <- df %>% pivot_longer(c("phi10", "phi50", "phi100"), names_to = "phi")

ggplot(data = df) +
  geom_density(aes(x = value, fill = phi, col = phi), alpha = 0.5) + 
  geom_density(aes(x = value, col = phi), alpha = 1, lwd = 1) + 
  xlab("s") +
  theme_classic()

ggplot(data = df) +
  geom_density(aes(x = abs(value), fill = phi, col = phi), alpha = 0.4) + 
  geom_density(aes(x = abs(value), col = phi), alpha = 1, lwd = 1) + 
  xlab("|s|") +
  theme_classic()
```

```{r, fig.width = 10, fig.height = 10}
gsd <- map(c(10,50,100),
    ~data.frame(read.csv(here(paste0("phi", .x, "_slattice_df.csv"))), phi = .x
  )) %>% bind_rows()

r <- raster::raster(nrows = 5, ncols = 5, xmn = 0, xmx = 100, ymn = -100, ymx = 0, vals = 1:25)
gsd$group <- raster::extract(r, gsd[,c("x","y")])
gsd$mismatch <- (abs(gsd$z1 - gsd$env1) + abs(gsd$z2 - gsd$env2))/2

ts <-
  gsd %>%
  group_by(t, phi) %>%
  summarize(across(everything(), mean))

ggplot(ts, aes(x = t, col = factor(phi))) +
  geom_point(aes(y = z1)) + 
  geom_point(aes(y = z2)) +
  geom_smooth(aes(y = z1)) +
  geom_smooth(aes(y = z2))

ts2 <-
  gsd %>%
  group_by(t, phi, group) %>%
  summarize(across(everything(), mean)) %>%
  pivot_longer(X0_0:X0_7)

ggplot(ts2, aes(x = t, y = value/2, col = phi, group = name)) +
  #geom_point() + 
  geom_smooth() +
  facet_wrap(~group, nrow = 5) +
  theme_void() 

```

```{r}
ggplot(ts, aes(x = t, y = mismatch, col = factor(phi))) +
  geom_smooth() +
  geom_point() +
  geom_line() +
  theme_classic()
```

```{r}
test <- stack("phi100_lattice.tif")
vals <- values(test) %>% data.frame() %>% pivot_longer(r.1:r.8)

ggplot(data = vals, aes(x = value, group = name)) +
  geom_density(fill = "black", alpha = 1/8) +
  theme_classic() +
  xlab("s")
```




